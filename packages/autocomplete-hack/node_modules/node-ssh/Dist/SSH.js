(function() {
  var Driver, FS, Promise, SSH;

  FS = require('fs');

  Driver = require('ssh2');

  Promise = require('a-promise');

  SSH = (function() {
    function SSH(Config) {
      this.Config = Config;
      if (typeof Config.username === 'undefined') {
        throw new Error("Please specify a valid Username");
      }
      if (typeof Config.host === 'undefined') {
        throw new Error("Please specify a valid Host");
      }
      if (Config.privateKey) {
        try {
          Config.privateKey = FS.readFileSync(Config.privateKey);
        } catch (_error) {
          throw new Error("Unable to read the Private Key File");
        }
      } else if (typeof Config.password === 'undefined') {
        throw new Error("Please specify a valid password or Private Key");
      }
      Config.port = Config.port || 22;
      this.Connected = false;
      this.Connection = new Driver();
    }

    SSH.prototype.connect = function() {
      return new Promise((function(_this) {
        return function(Resolve, Reject) {
          var error;
          try {
            _this.Connection.on('error', Reject);
            _this.Connection.on('ready', function() {
              _this.Connected = true;
              return Resolve();
            });
            return _this.Connection.connect(_this.Config);
          } catch (_error) {
            error = _error;
            return Reject(error);
          }
        };
      })(this));
    };

    SSH.prototype.mkdir = function(Path) {
      return this.exec("mkdir -p " + Path);
    };

    SSH.prototype.exec = function(Command, Opts) {
      if (!this.Connected) {
        throw new Error("Please connect before doing anything else");
      }
      Opts = Opts || {};
      return new Promise((function(_this) {
        return function(Resolve, Reject) {
          if (Opts.cwd) {
            Command = "cd " + Opts.cwd + "; " + Command;
          }
          return _this.Connection.exec(Command, function(Error, Stream) {
            var ToReturn;
            if (Error) {
              return Reject(Error);
            }
            ToReturn = {
              stdout: [],
              stderr: []
            };
            return Stream.on('close', function() {
              return Resolve({
                stderr: ToReturn.stderr.join(""),
                stdout: ToReturn.stdout.join("")
              });
            }).on('data', function(Data) {
              return ToReturn.stdout.push(Data.toString());
            }).stderr.on('data', function(Data) {
              return ToReturn.stderr.push(Data.toString());
            });
          });
        };
      })(this));
    };

    SSH.prototype.put = function(LocalFile, RemoteFile, SFTP, Retry) {
      if (Retry == null) {
        Retry = true;
      }
      if (!this.Connected) {
        throw new Error("Please connect before doing anything else");
      }
      return new Promise((function(_this) {
        return function(Resolve, Reject) {
          var ThePromise;
          try {
            FS.accessSync(LocalFile, FS.R_OK);
          } catch (_error) {
            return Reject("Local File '" + LocalFile + "' doesn't exist");
          }
          if (SFTP) {
            ThePromise = Promise.resolve(SFTP);
          } else {
            ThePromise = _this.requestSFTP();
          }
          return ThePromise.then(function(SFTP) {
            return SFTP.fastPut(LocalFile, RemoteFile, function(Error) {
              if (!Error) {
                return Resolve();
              }
              if (Error.message !== 'No such file' || !Retry) {
                return Reject(Error);
              }
              return _this.mkdir(RemoteFile.split("/").slice(0, -1).join('/')).then(function() {
                return _this.put(LocalFile, RemoteFile, SFTP, false);
              });
            });
          });
        };
      })(this));
    };

    SSH.prototype.putMulti = function(Files, SFTP) {
      if (!this.Connected) {
        throw new Error("Please connect before doing anything else");
      }
      return new Promise((function(_this) {
        return function(Resolve, Reject) {
          var Promises, ThePromise;
          if (SFTP) {
            ThePromise = Promise.resolve(SFTP);
          } else {
            ThePromise = _this.requestSFTP();
          }
          Promises = [];
          return ThePromise.then(function(SFTP) {
            Files.forEach(function(File) {
              if (!(File.Local || File.Remote)) {
                return;
              }
              if (!FS.existsSync(File.Local)) {
                return;
              }
              return Promises.push(_this.put(File.Local, File.Remote, SFTP));
            });
            return Promise.all(Promises).then(Resolve, Reject);
          });
        };
      })(this));
    };

    SSH.prototype.get = function(RemoteFile, LocalFile, SFTP) {
      if (!this.Connected) {
        throw new Error("Please connect before doing anything else");
      }
      return new Promise((function(_this) {
        return function(Resolve, Reject) {
          var ThePromise;
          if (SFTP) {
            ThePromise = Promise.resolve(SFTP);
          } else {
            ThePromise = _this.requestSFTP();
          }
          return ThePromise.then(function(SFTP) {
            var Contents, Stream;
            Stream = SFTP.createReadStream(RemoteFile);
            Contents = [];
            return Stream.on('data', function(Data) {
              return Contents.push(Data.toString());
            }).on('close', function() {
              Contents = Contents.join('');
              if (!LocalFile) {
                return Resolve(Contents);
              }
              return FS.writeFile(LocalFile, Contents, function(error) {
                if (error) {
                  return Reject(error);
                }
                return Resolve();
              });
            });
          });
        };
      })(this));
    };

    SSH.prototype.requestSFTP = function() {
      if (!this.Connected) {
        throw new Error("Please connect before doing anything else");
      }
      return new Promise((function(_this) {
        return function(Resolve, Reject) {
          return _this.Connection.sftp(function(Error, SFTP) {
            if (Error) {
              return Reject(Error);
            }
            return Resolve(SFTP);
          });
        };
      })(this));
    };

    SSH.prototype.end = function() {
      return this.Connection.end();
    };

    return SSH;

  })();

  module.exports = SSH;

}).call(this);
